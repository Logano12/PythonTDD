
from flask import Flask, jsonify, request
from enum import Enum


# sizes 

class Size(Enum):
    SMALL = 'Small'
    MEDIUM = 'Medium'
    LARGE = 'Large'
    MEGA = 'Mega'

    @staticmethod
    def get_price(size):
        prices = {
            Size.SMALL: 1.50,
            Size.MEDIUM: 1.75,
            Size.LARGE: 2.05,
            Size.MEGA: 2.15,
        }
        return prices[size]

# bases

class Base(Enum):
    WATER = "Water"
    SPRITE = "Sprite"
    COKE = "Coke"
    DR_PEPPER = "Dr. Pepper"
    PEPSI = "Pepsi"
    LEAF_WINE = "Leaf wine"
    

#flavors 

class Flavor(Enum):
    LEMON = "lemon"
    CHERRY = "cherry"
    STRAWBERRY = "strawberry"
    MINT = "mint"
    BLUEBERRY = "blueberry"
    LIME = "lime"


# drink class asking for base size and flavors

class Drink:
    def __init__(self, base, size):
        base = base.lower()
        found_base = next((b for b in Base if b.value.lower() == base), None)
        if not found_base:
            raise ValueError(f"Invalid base: {base}")
        self.__base = found_base

        size = size.lower()
        found_size = next((s for s in Size if s.value.lower() == size), None)
        if not found_size:
            raise ValueError(f"Invalid size: {size}")
        self.__size = found_size

        self.__flavors = []

    def get_base(self):
        return self.__base

    def get_size(self):
        return self.__size

    def set_size(self, size):
        size = size.lower()
        found_size = next((s for s in Size if s.value.lower() == size), None)
        if not found_size:
            raise ValueError(f"Invalid size: {size}")
        self.__size = found_size

    def get_flavors(self):
        return list(self.__flavors)

    def add_flavor(self, flavor):
        flavor = flavor.lower()
        found_flavor = next((f for f in Flavor if f.value.lower() == flavor), None)
        if not found_flavor:
            raise ValueError(f"Invalid flavor: {flavor}")
        if found_flavor not in self.__flavors:
            self.__flavors.append(found_flavor)

    def get_num_flavors(self):
        return len(self.__flavors)

    def get_total(self):
        base_price = Size.get_price(self.__size)
        flavor_cost = 0.15 * self.get_num_flavors()
        return round(base_price + flavor_cost, 2)

    @property
    def cost(self):
        return self.get_total()

    def __str__(self):
        flavors = ", ".join(f.value for f in self.__flavors) or "none"
        return f"{self.__size.value} {self.__base.value} with {flavors}"
    
    
order class to add drinks 

class Order:
    def __init__(self):
        self.__items = []

    def add_item(self, drink):
        if isinstance(drink, Drink):
            self.__items.append(drink)
        else:
            raise TypeError("Only Drink objects allowed.")

    def get_total(self):
        return round(sum(drink.get_total() for drink in self.__items), 2)

    def get_total_with_tax(self):
        subtotal = self.get_total()
        tax = round(subtotal * 0.0725, 2)
        total = round(subtotal + tax, 2)
        return {"subtotal": subtotal, "tax": tax, "total": total}

    def get_receipt(self):
        drinks_list = []
        for i, drink in enumerate(self.__items, 1):
            drinks_list.append({
                "number": i,
                "base": drink.get_base().value,
                "size": drink.get_size().value,
                "flavors": [f.value for f in drink.get_flavors()],
                "drink_total": drink.get_total()
            })
        totals = self.get_total_with_tax()
        return {
            "drinks": drinks_list,
            "subtotal": totals["subtotal"],
            "tax": totals["tax"],
            "total": totals["total"]
        }
        
        
        
        
app = Flask(__name__)
order = Order()

@app.route('/menu', methods=['GET'])
def menu():
    bases = [b.value for b in Base]
    flavors = [f.value for f in Flavor]
    sizes = [s.value for s in Size]
    return jsonify({"bases": bases, "flavors": flavors, "sizes": sizes})

@app.route('/drink', methods=['POST'])
def add_drink():
    data = request.json
    try:
        drink = Drink(data['base'], data['size'])
        for flavor in data.get('flavors', []):
            drink.add_flavor(flavor)
        order.add_item(drink)
        return jsonify({"message": "Drink added successfully."}), 201
    except ValueError as e:
        return jsonify({"error": str(e)}), 400

@app.route('/order/receipt', methods=['GET'])
def receipt():
    return jsonify(order.get_receipt())

if __name__ == '__main__':
    app.run(debug=True)
    
    


# improved unit test 
# testing drink and order a drink with one flavor the order total and the receipt structure

import unittest
from Module2Assignment import Drink, Order

class TestDrinkAndOrder(unittest.TestCase):
    def test_valid_drink_creation(self):
        d = Drink("Sprite", "Medium")
        self.assertEqual(d.get_base().value, "Sprite")
        self.assertEqual(d.get_flavors(), [])
        self.assertEqual(d.get_num_flavors(), 0)

    def test_drink_with_one_flavor(self):
        d = Drink("Dr. Pepper", "Large")
        d.add_flavor("cherry")
        self.assertEqual(d.get_base().value, "Dr. Pepper")
        self.assertEqual([f.value for f in d.get_flavors()], ["cherry"])
        self.assertEqual(d.get_num_flavors(), 1)

    def test_order_total(self):
        order = Order()
        d1 = Drink("Coke", "Small")
        d1.add_flavor("lemon")
        d1.add_flavor("mint")
        order.add_item(d1)
        self.assertAlmostEqual(order.get_total(), 1.50 + 0.30)

    def test_receipt_structure(self):
        order = Order()
        d = Drink("Pepsi", "Mega")
        d.add_flavor("lime")
        order.add_item(d)
        receipt = order.get_receipt()
        self.assertIn("subtotal", receipt)
        self.assertIn("tax", receipt)
        self.assertIn("total", receipt)
        self.assertEqual(receipt["drinks"][0]["base"], "Pepsi")
        self.assertEqual(receipt["drinks"][0]["flavors"], ["lime"])

if __name__ == '__main__':
    unittest.main()
